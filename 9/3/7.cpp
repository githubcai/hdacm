/*
HDU 3389 阶梯博弈 
多的拿到少的上面去，满足一定条件
 
阶梯博弈:博弈在一列阶梯上进行,每个阶梯上放着自然数个点,
两个人进行阶梯博弈，每一步则是将一个集体上的若干个点
(>=1 )移到前面去,最后没有点可以移动的人输。

(A+B)=6k+3(k >= 0)，对于两个盒子A,B可行的转移也可以想出来，
B%6==0的盒子可以转移到B%6==3的盒子里， 所以整体不变 
B%6==1的盒子可以转移到B%6==2的盒子
B%6==4的盒子可以转移到B%6==5的盒子
0 -> 3 -> 0 -> 3
2 -> 1 -> 2 -> 1
5 -> 4 -> 5 -> 4
最后的1, 3, 4盒子都是不能继续转移的盒子，
首先对于每一个转移公式都是互不影响的，对于第一个转移公式我们可以发现如果当前决策者处于不利形势，
他想要挽回形式而移动x%6==3的盒子到x%6==0的盒子是完全没用的，
因为对手总是可以继续把你转移的盒子再转移回x%6==3的盒子里使得你还是处于同样的劣势，

1,3,4 的状态不能转移到其他状态; 其他每个状态皆可转移;
且位置特定, 如2->1,5->4, 6->3, 7->2, 8->1 9->6

其本质我们有N级阶梯,现在要在%3的余数间转移, 0->0, 1->2, 2->1; 
其最后的结果为1, 3, 4; 那么他们的转移的步数的奇偶性也会确定，
我们只要选择步数为奇数的位置做nim博弈就行了;
而可以通过打表归纳证明得出模6为0、2、5的位置移动步数为奇，其余为偶。
*/
#include <cstdio>

int main(){
    int T; scanf("%d", &T);
    int cnt = 0;
    while(T-- > 0){
        int n; scanf("%d", &n);
        int ans = 0;
        for(int i = 1; i <= n; ++i){
            int t; scanf("%d", &t);
            if(i % 6 == 0 || i % 6 == 2 || i % 6 == 5) ans ^= t;
        }
        printf("Case %d: ", ++cnt);
        if(ans == 0){
            printf("Bob\n");
        }else{
            printf("Alice\n");
        }
    }
    return 0;
}
